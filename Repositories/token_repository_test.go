package repositories_test

import (
	domain "A2SV_Starter_Project_Blog/Domain"
	repositories "A2SV_Starter_Project_Blog/Repositories"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// TokenRepositorySuite defines the test suite
type TokenRepositorySuite struct {
	suite.Suite
	collection *mongo.Collection
	repository *repositories.MongoTokenRepository
}

// SetupSuite runs once before all tests in the suite
func (s *TokenRepositorySuite) SetupSuite() {
	s.collection = testDB.Collection("tokens_test")
	s.repository = repositories.NewMongoTokenRepository(testDB, "tokens_test")
}

// SetupTest runs before each individual test function
func (s *TokenRepositorySuite) SetupTest() {
	// Clean the collection to ensure test isolation
	s.Require().NoError(s.collection.Drop(context.Background()), "Failed to drop collection")
}

// TestTokenRepositorySuite is the entry point for running the test suite
func TestTokenRepositorySuite(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode.")
	}
	t.Parallel()
	suite.Run(t, new(TokenRepositorySuite))
}

// --- The Actual Tests ---

func (s *TokenRepositorySuite) TestStore() {
	ctx := context.Background()
	token := &domain.Token{
		ID:        primitive.NewObjectID().Hex(),
		UserID:    "user-123",
		Type:      domain.TokenTypeRefresh,
		Value:     "a-unique-refresh-token",
		ExpiresAt: time.Now().Add(1 * time.Hour).UTC().Truncate(time.Millisecond),
	}

	// Act
	err := s.repository.Store(ctx, token)
	s.Require().NoError(err)

	// Assert: Verify directly from the database
	var result bson.M
	err = s.collection.FindOne(ctx, bson.M{"value": "a-unique-refresh-token"}).Decode(&result)
	s.Require().NoError(err)
	s.Equal(token.UserID, result["user_id"])
	s.Equal(string(token.Type), result["type"])
}

func (s *TokenRepositorySuite) TestGetByValue() {
	ctx := context.Background()
	// Arrange: Pre-insert a token to find
	token := &domain.Token{
		ID:        primitive.NewObjectID().Hex(),
		UserID:    "user-456",
		Type:      domain.TokenTypePasswordReset,
		Value:     "a-findable-token",
		ExpiresAt: time.Now().Add(15 * time.Minute).UTC().Truncate(time.Millisecond),
	}
	err := s.repository.Store(ctx, token)
	s.Require().NoError(err)

	s.Run("Success - Token Found", func() {
		// Act
		foundToken, err := s.repository.GetByValue(ctx, "a-findable-token")

		// Assert
		s.Require().NoError(err)
		s.Require().NotNil(foundToken)
		s.Equal(token.ID, foundToken.ID)
		s.Equal(token.UserID, foundToken.UserID)
		s.Equal(token.Value, foundToken.Value)
	})

	s.Run("Failure - Token Not Found", func() {
		// Act
		foundToken, err := s.repository.GetByValue(ctx, "a-non-existent-token")

		// Assert
		// The repository implementation correctly returns an error when no documents are found
		s.Require().Error(err)
		s.Equal(mongo.ErrNoDocuments, err)
		s.Nil(foundToken)
	})
}

func (s *TokenRepositorySuite) TestGetByID() {
	ctx := context.Background()

	// Arrange: Store a token that we can fetch later.
	tokenToStore := &domain.Token{
		// The ID will be generated by Mongo, so we leave it empty.
		UserID:    "user-get-by-id-test",
		Type:      domain.TokenTypeActivation,
		Value:     "unique-activation-token-for-get-by-id",
		ExpiresAt: time.Now().Add(1 * time.Hour),
	}

	// We need to use the concrete repo to get the generated ID back.
	// Let's store it and retrieve its ID.
	err := s.repository.Store(ctx, tokenToStore)
	s.Require().NoError(err)
	s.Require().NotEmpty(tokenToStore.ID, "Store should populate the token ID")

	s.Run("Success - Token Found", func() {
		// Act: Fetch the token using the ID that was just generated.
		foundToken, err := s.repository.GetByID(ctx, tokenToStore.ID)

		// Assert
		s.Require().NoError(err)
		s.Require().NotNil(foundToken)
		s.Equal(tokenToStore.ID, foundToken.ID)
		s.Equal(tokenToStore.UserID, foundToken.UserID)
		s.Equal(tokenToStore.Value, foundToken.Value)
	})

	s.Run("Failure - Token Not Found (Valid ID)", func() {
		// Act: Try to fetch a token with a valid but non-existent ID.
		nonExistentID := primitive.NewObjectID().Hex()
		foundToken, err := s.repository.GetByID(ctx, nonExistentID)

		// Assert
		s.Require().Error(err, "Should return an error for a non-existent token")
		// Assuming your implementation maps mongo.ErrNoDocuments to usecases.ErrNotFound
		s.ErrorIs(err, domain.ErrNotFound, "Error should be ErrNotFound")
		s.Nil(foundToken)
	})

	s.Run("Failure - Invalid ID Format", func() {
		// Act: Try to fetch a token with a malformed ID string.
		invalidID := "this-is-not-a-valid-object-id"
		foundToken, err := s.repository.GetByID(ctx, invalidID)

		// Assert
		s.Require().Error(err)
		// Assuming your implementation maps this to domain.ErrInvalidID
		s.ErrorIs(err, domain.ErrInvalidID, "Error should be ErrInvalidID for malformed hex")
		s.Nil(foundToken)
	})
}

func (s *TokenRepositorySuite) TestDelete() {
	ctx := context.Background()
	// Arrange: Store a token to be deleted
	token := &domain.Token{
		ID:    primitive.NewObjectID().Hex(),
		Value: "token-to-delete",
	}
	err := s.repository.Store(ctx, token)
	s.Require().NoError(err)

	s.Run("Success - Delete Existing Token", func() {
		// Act
		err := s.repository.Delete(ctx, token.ID)
		s.Require().NoError(err)

		// Assert: Verify it's gone from the DB
		_, err = s.repository.GetByValue(ctx, "token-to-delete")
		s.Require().Error(err, "Token should not be found after deletion")
		s.Equal(mongo.ErrNoDocuments, err)
	})

	s.Run("Failure - Delete Non-Existent Token", func() {
		// Act
		err := s.repository.Delete(ctx, primitive.NewObjectID().Hex())

		// Assert: Your implementation returns a custom error
		s.Require().Error(err)
		s.Equal("token not found", err.Error())
	})
}

func (s *TokenRepositorySuite) TestDeleteByUserID() {
	ctx := context.Background()
	// Arrange: Store multiple tokens for multiple users
	s.repository.Store(ctx, &domain.Token{ID: primitive.NewObjectID().Hex(), UserID: "user-abc", Type: domain.TokenTypeRefresh, Value: "abc-refresh-1"})
	s.repository.Store(ctx, &domain.Token{ID: primitive.NewObjectID().Hex(), UserID: "user-abc", Type: domain.TokenTypeRefresh, Value: "abc-refresh-2"})
	s.repository.Store(ctx, &domain.Token{ID: primitive.NewObjectID().Hex(), UserID: "user-abc", Type: domain.TokenTypeActivation, Value: "abc-activation"})
	s.repository.Store(ctx, &domain.Token{ID: primitive.NewObjectID().Hex(), UserID: "user-xyz", Type: domain.TokenTypeRefresh, Value: "xyz-refresh"})

	// Act
	err := s.repository.DeleteByUserID(ctx, "user-abc", domain.TokenTypeRefresh)
	s.Require().NoError(err)

	// Assert: Check the state of the database
	var count int64

	// Tokens for user-abc of type refresh should be gone
	count, _ = s.collection.CountDocuments(ctx, bson.M{"user_id": "user-abc", "type": domain.TokenTypeRefresh})
	s.Equal(int64(0), count, "Refresh tokens for user-abc should have been deleted")

	// Activation token for user-abc should still exist
	count, _ = s.collection.CountDocuments(ctx, bson.M{"user_id": "user-abc", "type": domain.TokenTypeActivation})
	s.Equal(int64(1), count, "Activation token for user-abc should not have been deleted")

	// Token for user-xyz should still exist
	count, _ = s.collection.CountDocuments(ctx, bson.M{"user_id": "user-xyz"})
	s.Equal(int64(1), count, "Token for user-xyz should not have been deleted")
}

// TestCreateIndexes verifies that all necessary indexes are created correctly.
func (s *TokenRepositorySuite) TestCreateIndexes() {
	ctx := context.Background()

	// Act: Call the function to create the indexes.
	err := s.repository.CreateTokenIndexes(ctx)
	s.Require().NoError(err, "CreateIndexes should not return an error")

	// Assert: List the indexes from the database and verify them.
	cursor, err := s.collection.Indexes().List(ctx)
	s.Require().NoError(err, "Failed to list collection indexes")

	var indexes []bson.M
	err = cursor.All(ctx, &indexes)
	s.Require().NoError(err, "Failed to decode indexes from cursor")

	// Create a map of index names to their full spec for easy lookups.
	indexMap := make(map[string]bson.M)
	for _, idx := range indexes {
		s.T().Logf("Found index: %v", idx) // Helpful for debugging
		indexMap[idx["name"].(string)] = idx
	}

	// There should be the default "_id_" index plus our 3 custom ones.
	s.Len(indexMap, 4, "Expected 4 indexes in total")

	// 1. Verify the unique index on 'value'
	s.Run("Value Index", func() {
		valueIndex, exists := indexMap["value_1"]
		s.True(exists, "Index 'value_1' should exist")
		keyDoc := valueIndex["key"].(bson.M)
		s.Len(keyDoc, 1, "Value index key should have exactly one field")
		s.Equal(int32(1), keyDoc["value"], "Value index should be on 'value' with ascending order")
		s.True(valueIndex["unique"].(bool), "Value index should be unique")
	})

	// 2. Verify the compound index on 'user_id' and 'type'
	s.Run("User-Type Compound Index", func() {
		userTypeIndex, exists := indexMap["user_id_1_type_1"]
		if !exists {
			userTypeIndex, exists = indexMap["type_1_user_id_1"]
		}
		s.True(exists, "Index 'user_id_1_type_1' or 'type_1_user_id_1' should exist")
		keyDoc := userTypeIndex["key"].(bson.M)
		s.Len(keyDoc, 2, "User-Type index key should have exactly two fields")
		s.Equal(int32(1), keyDoc["user_id"], "User-Type index should include 'user_id'")
		s.Equal(int32(1), keyDoc["type"], "User-Type index should include 'type'")
		_, isUnique := userTypeIndex["unique"]
		s.False(isUnique, "User-Type index should not be unique")
	})

	// 3. Verify the TTL index on 'expires_at'
	s.Run("ExpiresAt TTL Index", func() {
		ttlIndex, exists := indexMap["expires_at_1"]
		s.True(exists, "Index 'expires_at_1' should exist")
		keyDoc := ttlIndex["key"].(bson.M)
		s.Len(keyDoc, 1, "TTL index key should have exactly one field")
		s.Equal(int32(1), keyDoc["expires_at"], "TTL index should be on 'expires_at'")
		s.EqualValues(0, ttlIndex["expireAfterSeconds"], "TTL index should expire after 0 seconds")
	})
}

// A parallel test out of suite because it may wait 65 seconds
func TestTokenTTL_Parallel(t *testing.T) {
	t.Parallel()

	// 2. Perform its own setup, because it's not part of the suite's lifecycle.
	// Use a unique collection name to guarantee isolation.
	collectionName := "tokens_ttl_parallel_test"
	collection := testDB.Collection(collectionName)
	repo := repositories.NewMongoTokenRepository(testDB, collectionName)

	// Ensure the collection is clean after the test.
	defer func() {
		collection.Drop(context.Background())
	}()

	ctx := context.Background()

	// 3. The rest of the test logic is the same.
	err := repo.CreateTokenIndexes(ctx)
	require.NoError(t, err, "Failed to create indexes for TTL test")

	expiredToken := &domain.Token{
		ID:        primitive.NewObjectID().Hex(),
		UserID:    "user-ttl-parallel",
		Type:      domain.TokenTypeActivation,
		Value:     "a-parallel-token-that-will-expire",
		ExpiresAt: time.Now().Add(3 * time.Second).UTC(),
	}

	err = repo.Store(ctx, expiredToken)
	require.NoError(t, err, "Failed to store the expired token")

	count, err := collection.CountDocuments(ctx, bson.M{"value": expiredToken.Value})
	require.NoError(t, err)
	require.Equal(t, int64(1), count, "Token should exist immediately")

	require.Eventually(t, func() bool {
		count, err := collection.CountDocuments(ctx, bson.M{"value": expiredToken.Value})
		require.NoError(t, err)
		return count == 0
	}, time.Duration(ttlWait+5)*time.Second, 1000*time.Millisecond, "Expired token should have been deleted")
}
