package repositories

import (
	domain "A2SV_Starter_Project_Blog/Domain"
	usecases "A2SV_Starter_Project_Blog/Usecases"
	"context"
	"errors"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type BlogModel struct {
	ID        primitive.ObjectID `bson:"_id,omitempty"`
	Title     string             `bson:"title"`
	Content   string             `bson:"content"`
	AuthorID  primitive.ObjectID `bson:"author_id"`
	Tags      []string           `bson:"tags"`
	Views     int64              `bson:"views"`
	Likes     int64              `bson:"likes"`
	Dislikes  int64              `bson:"dislikes"`
	CreatedAt time.Time          `bson:"created_at"`
	UpdatedAt time.Time          `bson:"updated_at"`
}

// blogRepository implements the domain.BlogRepository interface using MongoDB.
type blogRepository struct {
	collection *mongo.Collection
}

// NewBlogRepository is the constructor for the blog repository.
func NewBlogRepository(col *mongo.Collection) domain.IBlogRepository {
	return &blogRepository{
		collection: col,
	}
}

// --- Interface Implementations ---

func (r *blogRepository) Create(ctx context.Context, blog *domain.Blog) error {
	model, err := fromBlogDomain(blog) // Convert domain entity to persistence model
	if err != nil {
		return err
	}

	model.ID = primitive.NewObjectID() // Generate a new ID for the new document

	_, err = r.collection.InsertOne(ctx, model)
	if err != nil {
		// Translate a duplicate key error into our application-specific error
		if mongo.IsDuplicateKeyError(err) {
			return usecases.ErrConflict
		}
		return err // Return other DB errors as-is
	}

	// IMPORTANT: Update the domain object with the ID generated by the database.
	blog.ID = model.ID.Hex()

	return nil
}

func (r *blogRepository) GetByID(ctx context.Context, id string) (*domain.Blog, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		// An invalid hex string for an ID means it can't possibly be found.
		return nil, usecases.ErrNotFound
	}

	var model BlogModel
	err = r.collection.FindOne(ctx, bson.M{"_id": objID}).Decode(&model)
	if err != nil {
		// This is the crucial translation from a DB-specific error to a generic application error.
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, usecases.ErrNotFound
		}
		return nil, err
	}

	return toBlogDomain(&model), nil
}

func (r *blogRepository) SearchAndFilter(ctx context.Context, opts domain.BlogSearchFilterOptions) ([]*domain.Blog, int64, error) {
	// This slice will hold all our individual filter conditions.
	var conditions []bson.M

	// --- Build individual conditions ---
	if opts.Title != nil {
		conditions = append(conditions, bson.M{"title": bson.M{"$regex": *opts.Title, "$options": "i"}})
	}

	if len(opts.AuthorIDs) > 0 {
		// Convert hex string IDs from the domain layer to primitive.ObjectID for the DB query.
		var authorObjIDs []primitive.ObjectID
		for _, id := range opts.AuthorIDs {
			if objID, err := primitive.ObjectIDFromHex(id); err == nil {
				authorObjIDs = append(authorObjIDs, objID)
			}
		}
		if len(authorObjIDs) > 0 {
			conditions = append(conditions, bson.M{"author_id": bson.M{"$in": authorObjIDs}})
		}
	}

	if len(opts.Tags) > 0 {
		tagOperator := "$in"                        // Default to OR logic
		if opts.TagLogic == domain.GlobalLogicAND { // Using GlobalLogic type here as per your struct
			tagOperator = "$all"
		}
		conditions = append(conditions, bson.M{"tags": bson.M{tagOperator: opts.Tags}})
	}

	dateFilter := bson.M{}
	if opts.StartDate != nil {
		dateFilter["$gte"] = *opts.StartDate
	}
	if opts.EndDate != nil {
		dateFilter["$lte"] = *opts.EndDate
	}
	if len(dateFilter) > 0 {
		conditions = append(conditions, bson.M{"created_at": dateFilter})
	}

	// --- Construct the final filter ---
	var filter bson.M
	if len(conditions) == 0 {
		filter = bson.M{} // Empty filter matches all
	} else {
		// Default to AND logic
		operator := "$and"
		if opts.GlobalLogic == domain.GlobalLogicOR {
			operator = "$or"
		}
		filter = bson.M{operator: conditions}
	}

	// --- Configure find options for pagination and sorting ---
	findOptions := options.Find()
	findOptions.SetLimit(opts.Limit)
	findOptions.SetSkip((opts.Page - 1) * opts.Limit)

	sortValue := -1 // Default to DESC
	if opts.SortOrder == domain.SortOrderASC {
		sortValue = 1
	}
	var sortDoc bson.D
	switch opts.SortBy {
	case "popularity":
		sortDoc = bson.D{{Key: "views", Value: -1}, {Key: "likes", Value: -1}}
	case "title":
		sortDoc = bson.D{{Key: "title", Value: sortValue}}
	default: // "date" or any other value
		sortDoc = bson.D{{Key: "created_at", Value: sortValue}}
	}
	findOptions.SetSort(sortDoc)

	// --- Execute queries ---
	total, err := r.collection.CountDocuments(ctx, filter)
	if err != nil {
		return nil, 0, err
	}

	cursor, err := r.collection.Find(ctx, filter, findOptions)
	if err != nil {
		return nil, 0, err
	}
	defer cursor.Close(ctx)

	var blogs []*domain.Blog
	for cursor.Next(ctx) {
		var model BlogModel
		if err := cursor.Decode(&model); err != nil {
			return nil, 0, err
		}
		blogs = append(blogs, toBlogDomain(&model))
	}

	if err := cursor.Err(); err != nil {
		return nil, 0, err
	}

	return blogs, total, nil
}

func (r *blogRepository) Fetch(ctx context.Context, page, limit int64) ([]*domain.Blog, int64, error) {
	// First, get the total count of documents for pagination metadata.
	total, err := r.collection.CountDocuments(ctx, bson.M{})
	if err != nil {
		return nil, 0, err
	}

	// Configure find options for pagination and sorting.
	findOptions := options.Find()
	findOptions.SetLimit(limit)
	findOptions.SetSkip((page - 1) * limit)
	findOptions.SetSort(bson.D{{Key: "created_at", Value: -1}}) // Sort by most recent

	cursor, err := r.collection.Find(ctx, bson.M{}, findOptions)
	if err != nil {
		return nil, 0, err
	}
	defer cursor.Close(ctx) // Ensure the cursor is closed

	var blogs []*domain.Blog
	for cursor.Next(ctx) {
		var model BlogModel
		if err := cursor.Decode(&model); err != nil {
			return nil, 0, err // Stop and return on a decoding error
		}
		blogs = append(blogs, toBlogDomain(&model))
	}

	if err := cursor.Err(); err != nil {
		return nil, 0, err
	}

	return blogs, total, nil
}

func (r *blogRepository) Update(ctx context.Context, blog *domain.Blog) error {
	model, err := fromBlogDomain(blog)
	if err != nil {
		return err
	}

	objID, err := primitive.ObjectIDFromHex(blog.ID)
	if err != nil {
		return usecases.ErrNotFound
	}
	model.ID = objID // Ensure the model has the correct ObjectID

	filter := bson.M{"_id": model.ID}
	update := bson.M{"$set": model}

	res, err := r.collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return err
	}

	if res.MatchedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

func (r *blogRepository) Delete(ctx context.Context, id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return usecases.ErrNotFound
	}

	res, err := r.collection.DeleteOne(ctx, bson.M{"_id": objID})
	if err != nil {
		return err
	}

	if res.DeletedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

func (r *blogRepository) IncrementLikes(ctx context.Context, blogID string, value int) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return usecases.ErrInternal
	}
	filter := bson.M{"_id": objID}
	update := bson.M{"$inc": bson.M{"likes": value}}

	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err
}

func (r *blogRepository) IncrementDislikes(ctx context.Context, blogID string, value int) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return usecases.ErrInternal
	}
	filter := bson.M{"_id": objID}
	update := bson.M{"$inc": bson.M{"dislikes": value}}

	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err
}

func (r *blogRepository) IncrementViews(ctx context.Context, blogID string) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return err
	}
	filter := bson.M{"_id": objID}
	update := bson.M{"$inc": bson.M{"views": 1}}

	// Using UpdateOne is fine, it's a "fire-and-forget" operation.
	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err // The caller (e.g., a goroutine) can decide what to do with this error.
}

func (r *blogRepository) UpdateInteractionCounts(ctx context.Context, blogID string, likesInc, dislikesInc int) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return usecases.ErrNotFound
	}
	filter := bson.M{"_id": objID}

	// This single update modifies both fields atomically.
	// It will either completely succeed or completely fail.
	update := bson.M{
		"$inc": bson.M{
			"likes":    likesInc,
			"dislikes": dislikesInc,
		},
	}

	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err
}

// --- Mapper Functions ---

// toBlogDomain converts a persistence model (BlogModel) to a domain entity (Blog).
func toBlogDomain(model *BlogModel) *domain.Blog {
	return &domain.Blog{
		ID:        model.ID.Hex(),
		Title:     model.Title,
		Content:   model.Content,
		AuthorID:  model.AuthorID.Hex(),
		Tags:      model.Tags,
		Views:     model.Views,
		Likes:     model.Likes,
		Dislikes:  model.Dislikes,
		CreatedAt: model.CreatedAt,
		UpdatedAt: model.UpdatedAt,
	}
}

// fromBlogDomain converts a domain entity (Blog) to a persistence model (BlogModel).
// Note: This does not set the _id field, as that is handled during creation or update.
func fromBlogDomain(blog *domain.Blog) (*BlogModel, error) {
	authorID, err := primitive.ObjectIDFromHex(blog.AuthorID)
	if err != nil {
		return nil, usecases.ErrInternal // An invalid AuthorID string is an internal error
	}

	return &BlogModel{
		Title:     blog.Title,
		Content:   blog.Content,
		AuthorID:  authorID,
		Tags:      blog.Tags,
		Views:     blog.Views,
		Likes:     blog.Likes,
		Dislikes:  blog.Dislikes,
		CreatedAt: blog.CreatedAt,
		UpdatedAt: blog.UpdatedAt,
	}, nil
}
