package repositories

import (
	domain "A2SV_Starter_Project_Blog/Domain"
	usecases "A2SV_Starter_Project_Blog/Usecases"
	"context"
	"errors"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type BlogModel struct {
	ID        primitive.ObjectID `bson:"_id,omitempty"`
	Title     string             `bson:"title"`
	Content   string             `bson:"content"`
	AuthorID  primitive.ObjectID `bson:"author_id"`
	Tags      []string           `bson:"tags"`
	Views     int64              `bson:"views"`
	Likes     int64              `bson:"likes"`
	Dislikes  int64              `bson:"dislikes"`
	CreatedAt time.Time          `bson:"created_at"`
	UpdatedAt time.Time          `bson:"updated_at"`
}

// blogRepository implements the domain.BlogRepository interface using MongoDB.
type blogRepository struct {
	collection *mongo.Collection
}

// NewBlogRepository is the constructor for the blog repository.
func NewBlogRepository(col *mongo.Collection) domain.IBlogRepository {
	return &blogRepository{
		collection: col,
	}
}

// --- Interface Implementations ---

func (r *blogRepository) Create(ctx context.Context, blog *domain.Blog) error {
	model, err := fromDomain(blog) // Convert domain entity to persistence model
	if err != nil {
		return err
	}

	model.ID = primitive.NewObjectID() // Generate a new ID for the new document

	_, err = r.collection.InsertOne(ctx, model)
	if err != nil {
		// Translate a duplicate key error into our application-specific error
		if mongo.IsDuplicateKeyError(err) {
			return usecases.ErrConflict
		}
		return err // Return other DB errors as-is
	}

	// IMPORTANT: Update the domain object with the ID generated by the database.
	blog.ID = model.ID.Hex()

	return nil
}

func (r *blogRepository) GetByID(ctx context.Context, id string) (*domain.Blog, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		// An invalid hex string for an ID means it can't possibly be found.
		return nil, usecases.ErrNotFound
	}

	var model BlogModel
	err = r.collection.FindOne(ctx, bson.M{"_id": objID}).Decode(&model)
	if err != nil {
		// This is the crucial translation from a DB-specific error to a generic application error.
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, usecases.ErrNotFound
		}
		return nil, err
	}

	return toDomain(&model), nil
}

func (r *blogRepository) Fetch(ctx context.Context, page, limit int64) ([]*domain.Blog, int64, error) {
	// First, get the total count of documents for pagination metadata.
	total, err := r.collection.CountDocuments(ctx, bson.M{})
	if err != nil {
		return nil, 0, err
	}

	// Configure find options for pagination and sorting.
	findOptions := options.Find()
	findOptions.SetLimit(limit)
	findOptions.SetSkip((page - 1) * limit)
	findOptions.SetSort(bson.D{{Key: "created_at", Value: -1}}) // Sort by most recent

	cursor, err := r.collection.Find(ctx, bson.M{}, findOptions)
	if err != nil {
		return nil, 0, err
	}
	defer cursor.Close(ctx) // Ensure the cursor is closed

	var blogs []*domain.Blog
	for cursor.Next(ctx) {
		var model BlogModel
		if err := cursor.Decode(&model); err != nil {
			return nil, 0, err // Stop and return on a decoding error
		}
		blogs = append(blogs, toDomain(&model))
	}

	if err := cursor.Err(); err != nil {
		return nil, 0, err
	}

	return blogs, total, nil
}

func (r *blogRepository) Update(ctx context.Context, blog *domain.Blog) error {
	model, err := fromDomain(blog)
	if err != nil {
		return err
	}

	objID, err := primitive.ObjectIDFromHex(blog.ID)
	if err != nil {
		return usecases.ErrNotFound
	}
	model.ID = objID // Ensure the model has the correct ObjectID

	filter := bson.M{"_id": model.ID}
	update := bson.M{"$set": model}

	res, err := r.collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return err
	}

	if res.MatchedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

func (r *blogRepository) Delete(ctx context.Context, id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return usecases.ErrNotFound
	}

	res, err := r.collection.DeleteOne(ctx, bson.M{"_id": objID})
	if err != nil {
		return err
	}

	if res.DeletedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

// --- Mapper Functions ---

// toDomain converts a persistence model (BlogModel) to a domain entity (Blog).
func toDomain(model *BlogModel) *domain.Blog {
	return &domain.Blog{
		ID:        model.ID.Hex(),
		Title:     model.Title,
		Content:   model.Content,
		AuthorID:  model.AuthorID.Hex(),
		Tags:      model.Tags,
		Views:     model.Views,
		Likes:     model.Likes,
		Dislikes:  model.Dislikes,
		CreatedAt: model.CreatedAt,
		UpdatedAt: model.UpdatedAt,
	}
}

// fromDomain converts a domain entity (Blog) to a persistence model (BlogModel).
// Note: This does not set the _id field, as that is handled during creation or update.
func fromDomain(blog *domain.Blog) (*BlogModel, error) {
	authorID, err := primitive.ObjectIDFromHex(blog.AuthorID)
	if err != nil {
		return nil, usecases.ErrInternal // An invalid AuthorID string is an internal error
	}

	return &BlogModel{
		Title:     blog.Title,
		Content:   blog.Content,
		AuthorID:  authorID,
		Tags:      blog.Tags,
		Views:     blog.Views,
		Likes:     blog.Likes,
		Dislikes:  blog.Dislikes,
		CreatedAt: blog.CreatedAt,
		UpdatedAt: blog.UpdatedAt,
	}, nil
}
