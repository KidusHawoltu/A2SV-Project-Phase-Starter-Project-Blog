package repositories

import (
	domain "A2SV_Starter_Project_Blog/Domain"
	usecases "A2SV_Starter_Project_Blog/Usecases"
	"context"
	"errors"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const (
	LikeWeight    = 10.0
	DislikeWeight = -10.0
	ViewWeight    = 1.0
	// Constant for the Hacker News-style popularity formula.
	Gravity = 1.8
)

type BlogModel struct {
	ID              primitive.ObjectID `bson:"_id,omitempty"`
	Title           string             `bson:"title"`
	Content         string             `bson:"content"`
	AuthorID        primitive.ObjectID `bson:"author_id"`
	Tags            []string           `bson:"tags"`
	Views           int64              `bson:"views"`
	Likes           int64              `bson:"likes"`
	Dislikes        int64              `bson:"dislikes"`
	EngagementScore float64            `bson:"engagementScore"`
	CreatedAt       time.Time          `bson:"created_at"`
	UpdatedAt       time.Time          `bson:"updated_at"`
}

// blogRepository implements the domain.BlogRepository interface using MongoDB.
type blogRepository struct {
	collection *mongo.Collection
}

// NewBlogRepository is the constructor for the blog repository.
func NewBlogRepository(col *mongo.Collection) domain.IBlogRepository {
	return &blogRepository{
		collection: col,
	}
}

// --- Interface Implementations ---

func (r *blogRepository) Create(ctx context.Context, blog *domain.Blog) error {
	model, err := fromBlogDomain(blog) // Convert domain entity to persistence model
	if err != nil {
		return err
	}

	model.ID = primitive.NewObjectID() // Generate a new ID for the new document

	_, err = r.collection.InsertOne(ctx, model)
	if err != nil {
		// Translate a duplicate key error into our application-specific error
		if mongo.IsDuplicateKeyError(err) {
			return usecases.ErrConflict
		}
		return err // Return other DB errors as-is
	}

	// IMPORTANT: Update the domain object with the ID generated by the database.
	blog.ID = model.ID.Hex()

	return nil
}

func (r *blogRepository) GetByID(ctx context.Context, id string) (*domain.Blog, error) {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		// An invalid hex string for an ID means it can't possibly be found.
		return nil, usecases.ErrNotFound
	}

	var model BlogModel
	err = r.collection.FindOne(ctx, bson.M{"_id": objID}).Decode(&model)
	if err != nil {
		// This is the crucial translation from a DB-specific error to a generic application error.
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, usecases.ErrNotFound
		}
		return nil, err
	}

	return toBlogDomain(&model), nil
}

// SearchAndFilter is the main public method for querying blogs.
// It acts as a router, delegating to the most efficient query strategy
// based on whether the user is sorting by popularity.
func (r *blogRepository) SearchAndFilter(ctx context.Context, opts domain.BlogSearchFilterOptions) ([]*domain.Blog, int64, error) {
	if opts.SortBy == "popularity" {
		return r.executePopularityAggregation(ctx, opts)
	}
	return r.executeSimpleFind(ctx, opts)
}

// executeSimpleFind handles all non-popularity sorts using an efficient `find` command.
// This is faster than an aggregation pipeline for simple queries.
func (r *blogRepository) executeSimpleFind(ctx context.Context, opts domain.BlogSearchFilterOptions) ([]*domain.Blog, int64, error) {
	// 1. Build the filter document using the shared helper.
	filter, err := buildFilter(opts)
	if err != nil {
		return nil, 0, err
	}

	// 2. Get the total count of documents that match the filter for pagination.
	total, err := r.collection.CountDocuments(ctx, filter)
	if err != nil {
		return nil, 0, err
	}

	// 3. Configure find options for pagination and sorting.
	findOptions := options.Find()
	findOptions.SetLimit(opts.Limit)
	findOptions.SetSkip((opts.Page - 1) * opts.Limit)

	sortValue := -1 // Default to DESC
	if opts.SortOrder == domain.SortOrderASC {
		sortValue = 1
	}
	var sortDoc bson.D
	switch opts.SortBy {
	case "title":
		sortDoc = bson.D{{Key: "title", Value: sortValue}}
	default: // "date" or any other value defaults to sorting by creation date.
		sortDoc = bson.D{{Key: "created_at", Value: sortValue}}
	}
	findOptions.SetSort(sortDoc)

	// 4. Execute the find query.
	cursor, err := r.collection.Find(ctx, filter, findOptions)
	if err != nil {
		return nil, 0, err
	}
	defer cursor.Close(ctx)

	// 5. Decode the results.
	var blogs []*domain.Blog
	for cursor.Next(ctx) {
		var model BlogModel
		if err := cursor.Decode(&model); err != nil {
			return nil, 0, err
		}
		blogs = append(blogs, toBlogDomain(&model))
	}

	return blogs, total, cursor.Err()
}

// executePopularityAggregation handles the complex case of sorting by a calculated popularity score.
// It uses a MongoDB aggregation pipeline to compute the score on the fly.
func (r *blogRepository) executePopularityAggregation(ctx context.Context, opts domain.BlogSearchFilterOptions) ([]*domain.Blog, int64, error) {
	// 1. Build the filter document using the shared helper.
	filter, err := buildFilter(opts)
	if err != nil {
		return nil, 0, err
	}

	// 2. Get the total count before aggregation for pagination metadata.
	total, err := r.collection.CountDocuments(ctx, filter)
	if err != nil {
		return nil, 0, err
	}

	// Constants for the Hacker News-style popularity formula.
	now := time.Now()

	// 3. Define the aggregation pipeline.
	pipeline := mongo.Pipeline{
		// Stage 1: Filter documents to only those that match the search criteria.
		bson.D{{Key: "$match", Value: filter}},

		// Stage 2: Add a new field 'popularity' calculated on the fly.
		bson.D{{Key: "$addFields", Value: bson.D{
			{Key: "popularity", Value: bson.D{
				{Key: "$divide", Value: bson.A{
					// Numerator: The pre-calculated engagement score.
					"$engagementScore",
					// Denominator: (Time_In_Hours + 2) ^ Gravity
					bson.D{{Key: "$pow", Value: bson.A{
						bson.D{{Key: "$add", Value: bson.A{
							// Calculate age in hours: (Now - CreatedAt) / (ms in an hour)
							bson.D{{Key: "$divide", Value: bson.A{
								bson.D{{Key: "$subtract", Value: bson.A{now, "$created_at"}}},
								3600000,
							}}},
							2, // Add a buffer to prevent division by zero for new posts.
						}}},
						Gravity,
					}}},
				}},
			}},
		}}},

		// Stage 3: Sort by the newly calculated popularity field in descending order.
		bson.D{{Key: "$sort", Value: bson.D{{Key: "popularity", Value: -1}}}},

		// Stage 4 & 5: Apply pagination to the sorted results.
		bson.D{{Key: "$skip", Value: (opts.Page - 1) * opts.Limit}},
		bson.D{{Key: "$limit", Value: opts.Limit}},
	}

	// 4. Execute the aggregation pipeline.
	cursor, err := r.collection.Aggregate(ctx, pipeline)
	if err != nil {
		return nil, 0, err
	}
	defer cursor.Close(ctx)

	// 5. Decode the results.
	var blogs []*domain.Blog
	for cursor.Next(ctx) {
		var model BlogModel
		if err := cursor.Decode(&model); err != nil {
			return nil, 0, err
		}
		blogs = append(blogs, toBlogDomain(&model))
	}

	return blogs, total, cursor.Err()
}

// buildFilter is a helper function that constructs the MongoDB filter document
// from the search options. It is used by both find and aggregation queries.
func buildFilter(opts domain.BlogSearchFilterOptions) (bson.M, error) {
	// A slice to hold all individual filter conditions.
	var conditions []bson.M

	if opts.Title != nil {
		conditions = append(conditions, bson.M{"title": bson.M{"$regex": *opts.Title, "$options": "i"}})
	}

	if len(opts.AuthorIDs) > 0 {
		var authorObjIDs []primitive.ObjectID
		for _, id := range opts.AuthorIDs {
			if objID, err := primitive.ObjectIDFromHex(id); err == nil {
				authorObjIDs = append(authorObjIDs, objID)
			}
		}
		if len(authorObjIDs) > 0 {
			conditions = append(conditions, bson.M{"author_id": bson.M{"$in": authorObjIDs}})
		}
	}

	if len(opts.Tags) > 0 {
		tagOperator := "$in"
		if opts.TagLogic == domain.GlobalLogicAND {
			tagOperator = "$all"
		}
		conditions = append(conditions, bson.M{"tags": bson.M{tagOperator: opts.Tags}})
	}

	dateFilter := bson.M{}
	if opts.StartDate != nil {
		dateFilter["$gte"] = *opts.StartDate
	}
	if opts.EndDate != nil {
		dateFilter["$lte"] = *opts.EndDate
	}
	if len(dateFilter) > 0 {
		conditions = append(conditions, bson.M{"created_at": dateFilter})
	}

	// Construct the final filter based on the GlobalLogic.
	if len(conditions) == 0 {
		return bson.M{}, nil // Empty filter matches all documents.
	}

	operator := "$and" // Default to AND logic
	if opts.GlobalLogic == domain.GlobalLogicOR {
		operator = "$or"
	}
	return bson.M{operator: conditions}, nil
}

func (r *blogRepository) Update(ctx context.Context, blog *domain.Blog) error {
	model, err := fromBlogDomain(blog)
	if err != nil {
		return err
	}

	objID, err := primitive.ObjectIDFromHex(blog.ID)
	if err != nil {
		return usecases.ErrNotFound
	}
	model.ID = objID // Ensure the model has the correct ObjectID

	filter := bson.M{"_id": model.ID}
	update := bson.M{"$set": model}

	res, err := r.collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return err
	}

	if res.MatchedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

func (r *blogRepository) Delete(ctx context.Context, id string) error {
	objID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return usecases.ErrNotFound
	}

	res, err := r.collection.DeleteOne(ctx, bson.M{"_id": objID})
	if err != nil {
		return err
	}

	if res.DeletedCount == 0 {
		return usecases.ErrNotFound
	}

	return nil
}

func (r *blogRepository) IncrementLikes(ctx context.Context, blogID string, value int) error {
	return r.UpdateInteractionCounts(ctx, blogID, value, 0)
}

func (r *blogRepository) IncrementDislikes(ctx context.Context, blogID string, value int) error {
	return r.UpdateInteractionCounts(ctx, blogID, 0, value)
}

func (r *blogRepository) IncrementViews(ctx context.Context, blogID string) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return err
	}
	filter := bson.M{"_id": objID}
	update := bson.M{"$inc": bson.M{
		"views":           1,
		"engagementScore": ViewWeight,
	}}

	// Using UpdateOne is fine, it's a "fire-and-forget" operation.
	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err // The caller (e.g., a goroutine) can decide what to do with this error.
}

func (r *blogRepository) UpdateInteractionCounts(ctx context.Context, blogID string, likesInc, dislikesInc int) error {
	objID, err := primitive.ObjectIDFromHex(blogID)
	if err != nil {
		return usecases.ErrNotFound
	}
	filter := bson.M{"_id": objID}

	scoreChange := (float64(likesInc) * LikeWeight) + (float64(dislikesInc) * DislikeWeight)

	// This single update modifies both fields atomically.
	// It will either completely succeed or completely fail.
	update := bson.M{
		"$inc": bson.M{
			"likes":           likesInc,
			"dislikes":        dislikesInc,
			"engagementScore": scoreChange,
		},
	}

	_, err = r.collection.UpdateOne(ctx, filter, update)
	return err
}

// --- Mapper Functions ---

// toBlogDomain converts a persistence model (BlogModel) to a domain entity (Blog).
func toBlogDomain(model *BlogModel) *domain.Blog {
	return &domain.Blog{
		ID:        model.ID.Hex(),
		Title:     model.Title,
		Content:   model.Content,
		AuthorID:  model.AuthorID.Hex(),
		Tags:      model.Tags,
		Views:     model.Views,
		Likes:     model.Likes,
		Dislikes:  model.Dislikes,
		CreatedAt: model.CreatedAt,
		UpdatedAt: model.UpdatedAt,
	}
}

// fromBlogDomain converts a domain entity (Blog) to a persistence model (BlogModel).
// Note: This does not set the _id field, as that is handled during creation or update.
func fromBlogDomain(blog *domain.Blog) (*BlogModel, error) {
	authorID, err := primitive.ObjectIDFromHex(blog.AuthorID)
	if err != nil {
		return nil, usecases.ErrInternal // An invalid AuthorID string is an internal error
	}

	return &BlogModel{
		Title:           blog.Title,
		Content:         blog.Content,
		AuthorID:        authorID,
		Tags:            blog.Tags,
		Views:           blog.Views,
		Likes:           blog.Likes,
		Dislikes:        blog.Dislikes,
		EngagementScore: 0,
		CreatedAt:       blog.CreatedAt,
		UpdatedAt:       blog.UpdatedAt,
	}, nil
}
