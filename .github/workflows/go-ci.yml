# This is the name of the workflow. It will be displayed in the "Actions" tab of your GitHub repository.
name: Go CI

# This section defines when the workflow will run.
on:
  # Run on every push to the 'main' branch.
  push:
    branches: [ "main" ]
  # Also run on every pull request that targets the 'main' branch.
  pull_request:
    branches: [ "main" ]

# A workflow is made up of one or more "jobs" that can run in parallel or sequentially.
jobs:
  # We'll define a single job called "build-and-test".
  build-and-test:
    # This specifies the type of virtual machine to run the job on.
    # "ubuntu-latest" is a great, fast, and free choice for open-source projects.
    runs-on: ubuntu-latest
    services:
      mongo:
        image: mongo:6.0
        ports:
          - 27017:27017
      redis:
        image: redis:6-alpine
        ports:
          - 6379:6379

    # A job is a sequence of "steps".
    steps:
      # Step 1: Check out your repository's code.
      # This uses a pre-built "action" from the GitHub Marketplace.
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up the Go environment.
      # This action installs the specified version of Go.
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24' # Use the Go version that matches your project

      # Step 3: Install dependencies.
      # This step downloads all the Go modules your project needs.
      # It's cached, so it will be very fast on subsequent runs.
      - name: Install dependencies
        run: go mod download

      # Step 4: Build the application.
      # This command tries to compile your entire project. If it fails, the workflow fails.
      # It's a great way to catch syntax or compilation errors early.
      - name: Build
        run: go build -v ./...

      # Step 5: Run unit and integration tests.
      # This is the most important step. It runs all your tests.
      # The `-v` flag provides verbose output. The `-race` flag is a powerful
      # tool that detects race conditions in your concurrent code.
      # We use `go test` and not `go test -count=1` here because caching is handled
      # by the runner itself.
      - name: Run tests
        env:
          # For the database integration tests
          MONGO_URI_TEST: mongodb://localhost:${{ job.services.mongo.ports['27017'] }}
          DB_NAME_TEST: "ci_test_db"
          
          REDIS_ADDR_TEST: localhost:${{ job.services.redis.ports['6379'] }}
          REDIS_DB_TEST: 0
        run: go test -v -race ./...
      
      - name: Show MongoDB logs on failure
        if: failure()
        run: |
          echo "--- MongoDB Container Logs ---"
          docker logs ${{ job.services.mongo.id }}
          echo "--- Redis Container Logs ---"
          docker logs ${{ job.services.redis.id }}